# 常见蜜罐体验和探索 
--- 
## 实验目的  
* 了解蜜罐的分类和基本原理
* 了解不同类型蜜罐的适用场合
* 掌握常见蜜罐的搭建和使用   
## 实验要求  
- [x] 记录蜜罐的详细搭建过程
- [x] 使用nmap扫描搭建好的蜜罐并分析扫描结果，同时分析「nmap扫描期间」蜜罐上记录得到的信息  

- [x] 如何辨别当前目标是一个「蜜罐」？以自己搭建的蜜罐为例进行说明
- [x] 总结常见的蜜罐识别和检测方法  
## 网络拓扑  
![](img\topology.PNG)
---  
## 实验过程  
### 低交互蜜罐 ssh-honeypot  
* 安装docker（按照官方教程）  
  * 添加docker-ce的apt源  
  ```  
  apt-get update
  apt-get install -y apt-transport-https ca-certificates curl software-properties-common
  curl -fsSL https://download.daocloud.io/docker/linux/ubuntu/gpg | sudo apt-key add -  
  ```  
  * 添加docker的密钥  
  ```
  curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add -  
  ```  
  * 验证密钥的可用性并进行docker-ce的安装  
  ```  
  sudo apt-key fingerprint 0EBFCD88
  sudo apt-get update
  sudo apt-get install docker-ce# 安装 Docker  
  ```  
  * 开启docker服务并测试是否安装成功  
  ```  
  systemctl start docker
  sudo docker run hello-world  
  ```  
  ![](img\docker.PNG)  
* 安装ssh-honeypot  
    ```  
    apt install libssh-dev libjson-c-dev  # 安装依赖项 
    ssh-keygen -t rsa -f ./ssh-honeypot.rsa  # 先将ssh密码置为空
    git clone https://github.com/random-robbie/docker-ssh-honey
    docker build . -t local:ssh-honeypot#构建镜像
    docker run -p 2234:22 local:ssh-honeypot# 运行镜像 格式为本地端口:容器端口  
    docker ps #查看容器id
    docker exec -i -t id bash #用id进入容器
    tail -F ssh-honeypot.log#查看日志  
    ```  
    ![](img\bash.PNG)  
* 没进行ssh连接时，查看靶机日志  
![](img\before-log.PNG)  
日志上没有任何记录   

* 在攻击者主机上对蜜罐所在主机端口进行ssh连接  
![](img\after-log.PNG)  
可以看到，发起连接的主机地址被记录，尝试ssh连接时输入的账号密码也被记录，并且无论输入密码正确与否，都无法建立ssh连接   
* 对靶机进行nmap扫描，发现行为没有被记录下来  
![](img\ssh-nmap.PNG)   
再次说明了这是一个低交互的蜜罐，只能模拟登录过程并记录登录行为，并不能模拟登录的情况。  
### 中等交互蜜罐 cowrie  
* 安装cowrie  
```  
docker pull cowrie/cowrie  
docker run -p 2222:2222 cowrie/cowrie  
```   
* 对蜜罐所在端口进行ssh连接，查看日志（在/cowrie/cowrie-git/var/log/cowrie/cowrie.json路径下）
![](img\co-log.PNG)    
并且发现，使用root用户名登录时，无论密码正确与否都能登录；使用其他用户无论密码正确与否都登录不上  
![](img\co-kali.PNG)
![](img\co-root.PNG)  
一段时间后，ssh连接自动断开  
![](img\co-close-connection.PNG)
* 在攻击者主机上对靶机进行nmap扫描  
![](img\co-nmap.PNG)  
查看日志，发现刚才的扫描行为没有被记录  
![](img\co-aflog.PNG)  
* 用root用户登录后对蜜罐进行探索  
  * ping  
  ![](img\co-ping.PNG)  
    * 蜜罐给出一些假数据模拟回应，其实这里的218.177.158.130根本不是百度的ip地址  
    ![](img\218.PNG)  
  * curl  
  ![](img\co-curl.PNG)    
  看起来好像真的下载了网页数据  
  再来curl一个不存在网页hahaha  
  ![](img\curl-hahaha.PNG)  
  正常是不会返回数据的 
  ![](img\curl-haha.PNG)   
  * 想到curl就再探索一下wget  
   ![](img\wget.PNG)  
   可以说是很明显了😂
  * 输入apt相关指令  
  先来安装一个不存在的软件包  
  ![](img\apt-get1.PNG)  
  重复执行一下刚才的指令  
  ![](img\co-apt2.PNG)    
  但是正常情况下，如果这个包已经被安装过应该是下面这样的结果  
  ![](img\right-apt.PNG)  
  * 最后来看一下这个蜜罐可以模拟的指令,在这个路径下```~/cowrie-git/share/cowrie/txtcmds/bin/enable```
  ![](img\co-command.PNG)  
  可以模拟的命令还是挺多的  
  ---  
  ## 实验总结  
  **常见的蜜罐识别和检测方法**    
  * 实验中的感受  
    * 如果毫不费力的就能进入目标，说明可能触发的是蜜罐  
    * 多尝试几个命令，或者对某一个命令多添加一些不常见选项，或者故意使用错误口令都可能会漏出破绽  
  * 参考网上的理论 
    * 配置失真与资源抢夺  
    > 低交互蜜罐是不能够给敌人提供一个完整的操作系统环境，所以可以通过使用一些复杂的命令和操作，以及一些想不到的输出解决来检查是不是处在蜜罐环境中。  
    > 操作系统不可能把所有的资源都分配给蜜罐，所以我们可以在蜜罐中执行一个很繁琐很耗资源的操作，这样蜜罐就会和其他服务进程去争抢资源，最直观的感受就是蜜罐的反应速度会慢下来。
    * 数据包时间戳分析  
    > 如果我们仅通过查看网络数据包能很容易的推断出一个机器的物理属性，我们就很有可能辨别物理服务器和虚拟蜜罐。事实证明，TCP提供了一些直接反映底层服务器状态的信息。TCP时间戳选项被网络堆栈用于确定重传超时时间。机器中的无历史中安特定频率更新时间戳，我们也知道，所有的物理时钟都有一定时钟偏差，他们或多或少于实际运行时间。  

  ## 参考资料  
  [安装docker](https://medium.com/@calypso_bronte/installing-docker-in-kali-linux-2018-1-ef3a8ce3648)  
  [doocker-cowrie](https://github.com/cowrie/docker-cowrie)  
  [cowrie-document](https://cowrie.readthedocs.io/en/latest/index.html)  
  [师姐的实验报告](https://github.com/CUCCS/2019-NS-Public-YanhuiJessica/tree/ns0x11/ns-0x11)   
  [蜜罐初识](https://blog.csdn.net/jemy369/article/details/93722594)


